(in-package :ltpl)

;; X TODO Have a hub (function) where an error is pushed to the error-stream, a function is called
;; X TODO Write Parser Reader End function
;; X TODO Make errors better by accounting for the unknown token generated by the parser
;; X TODO Add Regular expression support

(defun eq-all (object &rest objects)
  (dolist (obj objects)
    (unless (eq obj object)
      (return-from eq-all nil)))
  t)

(defun eq-or (object &rest objects)
  (dolist (obj objects)
    (when (eq obj object)
      (return-from eq-or t))
    nil))

(defmacro appendf (lst )
  `(setf lst (append lst value)))

(defstruct box
  (data))

(defmacro string-join (str1 str2)
  `(concatenate 'string ,str1 ,str2))

(defmacro with-next-token (input-stream &body forms)
  `(let* ((next (read-object ,input-stream))
          (next-symbol (token-symbol next))
          (next-literal (token-literal next)))
     ,@forms))

(defmacro with-unboxed (&rest boxed-objects)
  `(let ((unboxed-pairs '()))
     (dolist (object ,boxed-objects)
       (push (cons (string-join "unboxed-" (symbol-name object)) (box-data object)) unboxed-pairs))
     unboxed-pairs))

(defun parse (input-stream)
  "Initial state of the parser. It creates the AST along reading the first token"
  (with-next-token input-stream
    (let* ((ast (make-box :data (make-node :data nil :left nil :right nil)))
           (error-list (make-box :data '())))
           (setf input-stream (make-box :data input-stream))

           (when (null next)
             (enqueue (cons "Encountered End Of Line At Beginning Of Token Stream" 'error) error-list))

      (parse-reader next input-stream error-list ast)))))

(defun parse-reader (token input-stream error-list ast)
  "parses valid reader directives"
  (with-next-token input-stream
    (let ((curr-symbol nil))
      (setf curr-symbol
            (cond ((string= (token-literal token) "--") 'line)
                  ((string= (token-literal token) "==") 'normal)
                  ((string= (token-literal token) "||") 'columns)
                  ((string= (token-literal token) "<=") 'backwards)
                  ((string= (token-literal token) "^^") 'bottom-up)
                  (t 'error)))
      ;;      (break  (format nil "~a" token))

      (cond ((eq curr-symbol 'error)
             (enqueue (cons (string-join "Found Unknown Reader-directive: " next-literal) 'error) error-list)
             (parse-unknown-token token input-stream error-list ast))

            ((null (token-symbol token))
             (enqueue (cons "Found End Of line Reader Directive:" 'error) error-list)))

      (unless (eq-or curr-symbol 'error nil)
        (insert-node (box-data ast) token))

      (case next-symbol
        (object-ref (parse-object-ref next input-stream error-list ast))
        (object-primitive (parse-object-primitive next input-stream error-list ast))
        (regex (parse-regex next input-stream error-list ast))
        (reader-end (parse-reader-end next input-stream error-list ast))
        (otherwise (enqueue (cons (string-join "Expected Expression, Object Or Reader End But Found: " next-literal) 'error) error-list)))
      (cons ast error-list))))

(defun parse-escape (token input-stream error-list ast)
  (with-next-token input-stream

    (if (and (eq (token-symbol token) 'action-end)
             (eq next-symbol 'action-begin))
        (setf (token-symbol token) 'working-object))

    (let ((possible-literal
            (cond ((string= next-literal "BEEP")      (string (code-char 7)))
                  ((string= next-literal "BACKSPACE") (string (code-char 8)))
                  ((string= next-literal "TAB")       (string (code-char 9)))
                  ((string= next-literal "VTAB")      (string (code-char 11)))
                  ((string= next-literal "CRETURN")   (string (code-char 13)))
                  ((string= next-literal "NEWLINE")   (string (code-char 10)))
                  ((string= next-literal "FFEED")     (string (code-char 12)))
                  ((string= next-literal "__")        (string #\SPACE))
                  (t 'error))))

      (cond ((null possible-literal) (enqueue (cons "Encountered End Of Line After Escape Sequence: " 'error) error-list))
            (t (enqueue (cons (string-join "Encountered Unrecognized Escape Sequence: " next-literal) 'error) error-list)))

      (case next-symbol
        (object-ref (parse-object-ref next input-stream error-list ast))
        (operator (parse-operator next input-stream error-list ast))
        (otherwise (enqueue (cons (string-join "Expected Object Reference But Found: " next-literal) ' error) error-list))))))

(defun parse-object-ref (token input-stream error-list ast &optional (acc '()))
  (with-next-token input-stream

    (setf (token-symbol token)
          (case (token-symbol token)
            (object-ref 'object-ref-part)
            (otherwise 'object-ref)))

    (break (format nil "~a" next))

    (insert-node (box-data ast) token)

    (cond ((string= next-literal "$") (parse-action token input-stream error-list ast))
          ((null (cons (string-join "Encountered End Of Line After Object Reference: " (token-literal token)) 'error))))

    (case next-symbol
      (range-delim (parse-range next input-stream error-list ast))
      (arg-delim (parse-arg next input-stream error-list ast))
      (reader-end (parse-reader-end next input-stream error-list ast))
      (object-ref (parse-object-ref next input-stream error-list ast))
      (otherwise (enqueue (cons (string-join "Unknown Or Invalid Token After Object Reference: " next-literal) 'error) error-list)))
    (cons ast error-list)))

(defun parse-object-primitive (token input-stream error-list ast)
  (with-next-token input-stream

    (break (format nil "~a" next))
    (when (eq (token-symbol token) 'action-begin)
      (setf next-symbol 'action-name))

    (insert-node (box-data ast) token)

    (when (null next)
      (enqueue (cons "Encountered End Of Line After Object Reference: " 'error) error-list))

    ;; checking the previous token to determine what the object primitive is
    (case next-symbol
      (action-begin (parse-action next input-stream error-list ast))
      (range-delim (parse-range next input-stream error-list ast))
      (object-ref (parse-object-ref next input-stream error-list ast))
      (reader-end (parse-reader-end next input-stream error-list ast))
      (action-reader-end (action-reader-end next input-stream error-list ast))
      (operator (parse-operator next input-stream error-list ast))
      (cons ast error-list))))

(defun parse-regex (token input-stream error-list ast)
  (with-next-token input-stream

    (break (format nil "~a" token))

    (insert-node (box-data ast) token)

    ;; Check and see if the token is a [
    (when (null next)
      (enqueue (cons "Encountered End Of Line After Regular Expression" 'error) error-list))

    (case next-symbol
      (operator (parse-operator next input-stream error-list ast))
      (action-begin (parse-action next input-stream error-list ast))
      (arg-delim (parse-arg next input-stream error-list ast))
      (otherwise (enqueue (cons (string-join "Unknown Or Invalid Token Found After Regular Expression:" next-literal) 'error) error-list))))
  (cons ast error-list))

(defun parse-arg (token input-stream error-list ast)
  (with-next-token input-stream

    (break (format nil "~a" next))

    (when (null next)
      (enqueue (cons (string-join "Encountered End Of Line After Parser Argument" next-literal) 'error) error-list))

    (case next-symbol
      (object-ref (parse-object-ref next input-stream error-list ast))
      (object-primitive (parse-object-primitive next input-stream error-list ast))
      (esc (parse-escape next input-stream error-list ast))
      (otherwise (enqueue (cons (string-join "Unknown Or Invalid Token Found After Regular Expression: " next-literal) 'error) error-list))))
  (cons ast error-list))

(defun parse-range (token input-stream error-list ast)
  (with-next-token input-stream

    (break (format nil "~a" next))

    (when (null next)
      (enqueue (cons "Encountered End Of Line After Parser Range" 'error) error-list))

    (break (format nil "not null ~a" next))

    (case next-symbol
      (object-ref (parse-object-ref next input-stream error-list ast))
      (object-primitive (parse-object-primitive next input-stream error-list ast))
      (t (enqueue (cons (string-join "Unknown Or Invalid Token Found After Parser Range" next-literal) 'error) error-list))))
  (cons ast error-list))

(defun parse-action (token input-stream error-list ast)
  (with-next-token input-stream
    (when (null next)
      (enqueue (cons "Encountered End Of Line After Parser Range Or Assignment" 'error) error-list))

    (break "In action ~a" next)

    (case next-symbol
      (object-primitive (parse-object-primitive next input-stream error-list ast))
      (object-ref (parse-object-ref next input-stream error-list ast))
      (otherwise (enqueue (cons (string-join "Unknown or Invalid Token Found After Parser Action: " next-literal) 'error) error-list))))
  (cons ast error-list))

(defun parse-unknown-token (token input-stream error-list ast)
  (with-next-token input-stream

    (enqueue (cons (string-join "Unknown Or Invalid Token Found After Parser Action: " (token-literal token)) 'error) error-list)
    (when (null token)
      (enqueue (cons "Encountered End Of Line After Unknown Token: " 'error) error-list))

    (case next-symbol
      (uknown-token (parse-unknown-token next input-stream error-list ast))
      (object-primitive (parse-object-primitive next input-stream error-list ast))
      (object-ref (parse-object-ref next input-stream error-list ast))

      (action-begin (parse-action next input-stream error-list ast))
      (action-end (parse-action-end next input-stream error-list ast))
      (operator (parse-operator next input-stream error-list ast))

      (range-delim (parse-range next input-stream error-list ast))
      (arg-delim (parse-arg next input-stream error-list ast))
      (regex (parse-regex next input-stream error-list ast))

      (esc (parse-escape next input-stream error-list ast))
      (reader (parse-reader token input-stream error-list ast))))
  (cons ast error-list))

(defun parse-operator (token input-stream error-list ast)
  (let ((stack '())
        (queue '()))

    ;; TODO add pemdas support
    ;; (when (null (parse-integer (token-literal tok) :junk-allowed t))
    ;;   (write-object (make-parser-error :token next :code 1 :severity 'warning))) ;; enacting operator

    ;; NOTE: does not parse PEMDAS, evals left top right
    (loop :for tok := (read-object input-stream)
          :if (or (eq (token-symbol tok) 'operator)
                  (eq (token-symbol tok) 'regex)) :do
                    (push tok stack)
          :else :if (eq (token-symbol tok) 'object) :do
            (enqueue tok queue)
          :else :do
            (when (null tok)
              (enqueue (cons "Encountered End Of Line After Operator" 'error) error-list))
            (enqueue (cons (string-join "Unknown Or Invalid Token Found In Expression: " next-literal) 'error) error-list)
            (loop-finish))

    (loop :for op :in stack :do
      (node-insert (box-data ast) op)
      (node-insert (box-data ast) (dequeue queue))
      (node-insert (box-data ast) (dequeue queue)))))

(defun parse-action-end (token input-stream error-list ast)
  (with-next-token input-stream
    ;; this may result as an error, currently debating on weather i want a EOL terminator or not, probably not tho
    ;; (when (null next)
    ;;   (report-error (make-parser-error :token token :code -8 :severity 'error)))
    (when (null next)
      (return-from parse-action-end (box-data (ast))))

    (case next-symbol
      (action-begin (parse-action next input-stream error-list ast))
      (object-primitive (parse-action next input-stream error-list ast))
      (object-ref (parse-action next input-stream error-list ast))
      (otherwise (enqueue (cons (string-join "Unknown or Invalid Token Found After Action End Token: " next-literal) 'error) error-list)))
    (cons ast error-list)))

(defun parse-reader-end (token input-stream error-list ast)
  (with-next-token input-stream
    (break (format nil "~a" next))

    (case next-symbol
      (action-begin (break "about to enter action") (parse-action next input-stream error-list ast))
      (object-primitive (parse-object-primitive next input-stream error-list ast))
      (object-ref (parse-object-ref next input-stream error-list ast))
      (otherwise (enqueue (cons (string-join "Found Unknown Token After Reader End"  next-literal) 'error) error-list))))
  (cons ast error-list))
