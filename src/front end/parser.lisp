(in-package :ltpl)

;; TODO Have a hub (function) where an error is pushed to the error-stream, a function is called
;; TODO Add Regular expression support
;; TODO Make errors better by accounting for the unknown token generated by the parser
;; TODO Write Parser Reader End function

(defstruct parser-error
  (token)
  (code)
  (severity))

(defstruct box
  (data))

(defun report-error-return (parser-error ast)
  (write-object *parser-error-stream* parser-error)
  ast)

(defparameter *parser-error-stream* (make-object-stream '()))

(defmacro with-next-token (input-stream &body forms)
  `(let* ((next (read-object ,input-stream))
          (next-symbol (token-symbol next)))
     ,@forms))

(defun parse (input-stream)
  "Initial state of the parser. It creates the AST along reading the first token"
  (let* ((token (read-object input-stream))
         (ast (make-box :data (make-node :data nil :left nil :right nil)))
         (symbol (token-symbol token)))

    (when (null token)
      (report-error-return (make-parser-error :token nil :code -1 :severity 'error) ast)) ;; file input is empty
    (parse-reader token input-stream ast)))

(defun parse-reader (token input-stream ast)
  (with-next-token input-stream
    (cond ((string= (token-literal token) "--") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'line)))
          ((string= (token-literal token) "==") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'normal)))
          ((string= (token-literal token) "||") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'columns)))
          ((string= (token-literal token) "<=") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'backwards)))
          ((string= (token-literal token) "^^") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'bottom-up)))
          (t (write-object (make-parser-error :token next :code -3 :severity 'error) *parser-error-stream*))) ;; invalid-parser-reader-found

    (when (null next)
      (report-error-return (make-parser-error :token token :code -4 :severity 'error) ast)) ;;  found end of line after reader-directive 

    (insert-node (box-data ast) token)

    (case next-symbol
      (object-ref (parse-object-ref next input-stream ast))
      (object-primitive (parse-object-ref next input-stream ast))
      (reader-end (parser-reader-end next input-stream ast))
      (otherwise (write-object (make-parser-error :token next :code -5 :severity 'error) *parser-error-stream*))))) ;; expected object expression or @ (ill figure out a fancy name for it later)

(defun parse-object-ref (token input-stream ast)
  (with-next-token input-stream
    (insert-node (box-data ast) token)

    (cond ((string= (token-literal next) "$") (parse-action token input-stream ast))
          ((null next) (report-error-return (make-parser-error :token token :code -7 :severity 'error) ast))) ;;found object that is not being enacted on by any action

    (case next-symbol
      (object-ref (parse-object-ref token input-stream ast))
      (range-delim (parse-range token input-stream ast))
      (arg-delim (parse-arg token input-stream ast))
      (otherwise (write-object (make-parser-error :token next :code -8 :severity 'error) *parser-error-stream*))))) ;; unresolved token after reference

(defun parse-object-primitive (token input-stream ast)
    (with-next-token input-stream
      (insert-node (box-data ast) token)

      (when (null next)
        (report-error-return (make-parser-error :token next :code -9 :severity 'error) ast)) ;;found object that is not being enacted on by any action

      (case next-symbol
        (action-begin (parse-action next input-stream ast))
        (range-delim (parse-range token input-stream ast))
        (object-ref (parse-object-ref token input-stream ast))
        (operator (parse-operator token input-stream ast)))))

(defun parse-arg (token input-stream ast)
  (with-next-token input-stream
    (when (null next)
      (report-error-return (make-parser-error :token token :code -9 :severity 'error))) ;; encountered end of line after parser arg

    (case next-symbol
      (object-ref (parse-object-ref token input-stream ast))
      (object-primitive (parse-object-primitive token input-stream ast))
      (t (write-object (make-parser-error :token next :code -10 :severity 'error) *parser-error-stream*))))) ;; expected an object after parser-arg

(defun parse-range (token input-stream ast)
  (with-next-token input-stream
    (when (null next)
      (report-error-return (make-parser-error :token token :code -9 :severity 'error))) ;; encountered end of line after parser range

    (case next-symbol
      (object-ref (parse-object-ref token input-stream ast))
      (object-primitive (parse-object-primitive token input-stream ast))
      (unknown-token (write-object 
      (t (write-object (make-parser-error :token next :code -10 :severity 'error) *parser-error-stream*))))))) ;; expected an object after parser range

;; (defun parse-reader-end (token input-stream ast)
;;   (with-next-token input-stream
;;     (when (null next)
;;       (report-error-return (make-parser-error :token token :code -11 :severity 'error)))

;;     (case next-symbol
;;       (

(defun parse-action (token input-stream ast)
  (with-next-token input-stream
    (when (null next)
      (report-error-return (make-parser-error :token token :code -12 :severity 'error) *parser-error-stream*))

    (case next-symbol
      (object-primitive (parse-object-primitive next input-stream ast))
      (object-ref (parse-object-ref next input-stream ast))
      (otherwise (write-object (make-parser-error :token next :code -12 :severity 'error) *parser-error-stream*)))))

(defun parse-unknown-token (token input-stream ast)
  (with-next-token input-stream
    (when (null token)
      (report-error-return (make-parser-error :token token :code -13 :severity 'error)))

    (case next-symbol
      (uknown-token (parse-unknown-token token input-stream ast))
      (object-primitive (parse-object-primitive token input-stream ast))
      (object-ref (parse-object-ref token input-stream ast))
      (action-begin (parse-action token input-stream ast))
      (action-end (parse-action-end token input-stream ast))
      (operator (parse-operator token input-stream ast))
      (range-delim (parse-range token input-stream ast))
      (arg-delim (parse-arg token input-stream ast))
      (esc (parse-escape token input-stream ast))
      (reader (parse-reader token input-stream ast)))))

(defun parse-operator (token input-stream ast)
  (let ((stack '())
        (queue '()))

    ;; going to report warnings here

    ;; (when (null (parse-integer (token-literal tok) :junk-allowed t))
    ;;   (write-object (make-parser-error :token next :code 1 :severity 'warning))) ;; enacting operator

    (loop :for tok := (read-object input-stream)
          :if (eq (token-symbol tok) 'operator) :do
            (push tok stack)
          :else :if (eq (token-symbol tok) 'object) :do
            (enqueue tok queue)
          :else :do
            (when (null tok)
              (report-error-return (make-parser-error :token tok :code -5 :severity 'error)))
            (case tok
              (unknown-token (write-object (make-parser-error :token tok :code -6 :severity 'error) *parser-error-stream*))
              (otherwise (write-object (make-parser-error :token tok :code -7 :severity 'error) *parser-error-stream*))) ;; found invalid next-token in expression
            (loop-finish))

    (loop :for op :in stack :do
      (node-insert (box-data ast) op)
      (node-insert (box-data ast) (dequeue queue))
      (node-insert (box-data ast) (dequeue queue)))))

(defun action-end (token input-stream ast)
  (with-next-token input-stream
    ;; this may result as an error, currently debating on weather i want a EOL terminator or not, probably not tho
    ;; (when (null next)
    ;;   (report-error (make-parser-error :token token :code -8 :severity 'error)))
    (when (null next)
      (return-from action-end ast))

    (case next-symbol
      (action-begin (parse-action token input-stream ast))
      (object-primitive (parse-action token input-stream ast))
      (object-ref (parse-action token input-stream ast))
      (unknown-token (write-object (make-parser-error :token next :code -8 :severity 'error) *parser-error-stream*)) ;; unknown next-token found after ]
      (otherwise (write-object (make-parser-error :token next :code -9 :severity 'error) *parser-error-stream*))))) ;; expected object or regular expression

;; (defun action-end (parse-action-end token input-stream ast)
;; )


