(in-package :ltpl)

;; X  TODO Have a hub (function) where an error is pushed to the error-stream, a function is called
;; X TODO Write Parser Reader End function
;; X TODO Make errors better by accounting for the unknown token generated by the parser
;; TODO Add Regular expression support

;; (defstruct parser-error
;;   (token)
;;   (code)
;;   (severity))

;; (defstruct box
;;   (data))

;; (defun report-error-return (parser-error ast)
;;   (write-object *parser-error-stream* parser-error)
;;   ast)

;; (defun report-error (parser-error input-stream ast)
;;   (with-token input-stream
;;     (write-object *parser-error-stream* parser-error)

;; (defparameter *parser-error-stream* (make-object-stream '()))

(defmacro with-next-token (input-stream &body forms)
  `(let* ((next (read-object ,input-stream))
          (next-symbol (token-symbol next)))
     ,@forms))

(defun parse (input-stream)
  "Initial state of the parser. It creates the AST along reading the first token"
  (let* ((token (read-object input-stream))
         (ast (make-box :data (make-node :data nil :left nil :right nil)))
         (symbol (token-symbol token)))

    (when (null token)
      (report-error-return (make-parser-error :token nil :code -1 :severity 'error) ast)) ;; file input is empty
    (parse-reader token input-stream ast)))

(defun parse-reader (token input-stream ast)
  (with-next-token input-stream
    (cond ((string= (token-literal token) "--") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'line)))
          ((string= (token-literal token) "==") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'normal)))
          ((string= (token-literal token) "||") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'columns)))
          ((string= (token-literal token) "<=") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'backwards)))
          ((string= (token-literal token) "^^") (insert-node (box-data ast) (make-token :literal (token-literal token) :symbol 'bottom-up)))
          (t (parser-report-error token -1 input-stream ast))) ;; invalid parser reader found 

    (when (null next)
      (parser-report-error-return (make-parser-error :token token :code -2 :severity 'error) ast)) ;;  found end of line after reader-directive 

    (insert-node (box-data ast) token)

    (case next-symbol
      (object-ref (parse-object-ref next input-stream ast))
      (object-primitive (parse-object-ref next input-stream ast))
      (reader-end (parser-reader-end next input-stream ast))
      (otherwise (parser-report-error token code input-stream ast))))) ;; expected object expression rather or reader end

(defun parse-object-ref (token input-stream ast)
  (with-next-token input-stream
    (insert-node (box-data ast) token)

    (cond ((string= (token-literal next) "$") (parse-action token input-stream ast))
          ((null next) (report-error-return (make-parser-error :token token :code -3 :severity 'error) ast))) ;;found object that is not being enacted on by any action

    (case next-symbol
      (object-ref (parse-object-ref token input-stream ast))
      (range-delim (parse-range token input-stream ast))
      (arg-delim (parse-arg token input-stream ast))
      (otherwise (write-object (make-parser-error :token next :code -4 :severity 'error) *parser-error-stream*))))) ;; unresolved token after reference

(defun parse-object-primitive (token input-stream ast)
  (with-next-token input-stream
    (insert-node (box-data ast) token)

    (when (null next)
      (report-error-return (make-parser-error :token next :code -5 :severity 'error) ast)) ;;found object that is not being enacted on by any action

    (case next-symbol
      (action-begin (parse-action next input-stream ast))
      (range-delim (parse-range token input-stream ast))
      (object-ref (parse-object-ref token input-stream ast))
      (operator (parse-operator token input-stream ast)))))

(defun parse-arg (token input-stream ast)
  (with-next-token input-stream
    (when (null next)
      (report-error-return (make-parser-error :token token :code -6 :severity 'error))) ;; encountered end of line after parser arg

    (case next-symbol
      (object-ref (parse-object-ref token input-stream ast))
      (object-primitive (parse-object-primitive token input-stream ast))
      (t (parser-report-error next -7 input-stream ast))))) ;; expected an object after parser-arg

(defun parse-range (token input-stream ast)
  (with-next-token input-stream
    (when (null next)
      (report-error-return (make-parser-error :token token :code -8 :severity 'error))) ;; encountered end of line after parser range

    (case next-symbol
      (object-ref (parse-object-ref token input-stream ast))
      (object-primitive (parse-object-primitive token input-stream ast))
      (unknown-token (write-object :token token :code -12 :severity 'error))
      (t (write-object (make-parser-error :token next :code -13 :severity 'error) *parser-error-stream*))))))) ;; expected an object after parser range

;; (defun parse-reader-end (token input-stream ast)
;;   (with-next-token input-stream
;;     (when (null next)
;;       (report-error-return (make-parser-error :token token :code -11 :severity 'error)))

;;     (case next-symbol
;;       (

(defun parse-action (token input-stream ast)
  (with-next-token input-stream
    (when (null next)
      (report-error-return (make-parser-error :token token :code -14 :severity 'error) *parser-error-stream*))

    (case next-symbol
      (object-primitive (parse-object-primitive next input-stream ast))
      (object-ref (parse-object-ref next input-stream ast))
      (otherwise (parser-report-error token -15 input-stream ast)))))

(defun parse-unknown-token (token input-stream ast)
  (with-next-token input-stream
    (when (null token)
      (report-error-return (make-parser-error :token token :code -15 :severity 'error) ast))) ;; after unknown token found eol

    (case next-symbol
      (uknown-token (parse-unknown-token token input-stream ast))
      (object-primitive (parse-object-primitive token input-stream ast))
      (object-ref (parse-object-ref token input-stream ast))
      (action-begin (parse-action token input-stream ast))
      (action-end (parse-action-end token input-stream ast))
      (operator (parse-operator token input-stream ast))
      (range-delim (parse-range token input-stream ast))
      (arg-delim (parse-arg token input-stream ast))
      (esc (parse-escape token input-stream ast))
      (reader (parse-reader token input-stream ast)))))

(defun parse-operator (token input-stream ast)
  (let ((stack '())
        (queue '()))

    ;; TODO add pemdas support

    ;; (when (null (parse-integer (token-literal tok) :junk-allowed t))
    ;;   (write-object (make-parser-error :token next :code 1 :severity 'warning))) ;; enacting operator

    ;; NOTE: does not parse PEMDAS, evals left to right
    (loop :for tok := (read-object input-stream)
          :if (eq (token-symbol tok) 'operator) :do
            (push tok stack)
          :else :if (eq (token-symbol tok) 'object) :do
            (enqueue tok queue)
          :else :do
            (when (null tok)
              (report-error-return (make-parser-error :token tok :code -14 :severity 'error)))
            (case tok
              (unknown-token (parser-report-error token -15 input-stream ast))
              (otherwise (parser-report-error token -16 input-stream ast))) ;; found invalid next-token in expression
            (loop-finish))

    (loop :for op :in stack :do
      (node-insert (box-data ast) op)
      (node-insert (box-data ast) (dequeue queue))
      (node-insert (box-data ast) (dequeue queue)))))

(defun action-end (token input-stream ast)
  (with-next-token input-stream
    ;; this may result as an error, currently debating on weather i want a EOL terminator or not, probably not tho
    ;; (when (null next)
    ;;   (report-error (make-parser-error :token token :code -8 :severity 'error)))
    (when (null next)
      (return-from action-end ast))

    (case next-symbol
      (action-begin (parse-action token input-stream ast))
      (object-primitive (parse-action token input-stream ast))
      (object-ref (parse-action token input-stream ast))
      (unknown-token (write-object (make-parser-error :token next :code -17 :severity 'error) *parser-error-stream*)) ;; unknown next-token found after ]
      (otherwise (write-object (make-parser-error :token next :code -18 :severity 'error) *parser-error-stream*))))) ;; expected object or regular expression

;; (defun action-end (parse-action-end token input-stream ast)
;; )


