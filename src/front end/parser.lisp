(in-package :ltpl)

;; X TODO Have a hub (function) where an error is pushed to the error-stream, a function is called
;; X TODO Write Parser Reader End function
;; X TODO Make errors better by accounting for the unknown token generated by the parser
;; X TODO Add Regular expression support

(defun eq-all (object &rest objects)
  (dolist (obj objects)
    (unless (eq obj object)
      (return-from eq-all nil)))
  t)

(defun eq-or (object &rest objects)
  (dolist (obj objects)
    (when (eq obj object)
      (return-from eq-or t))
    nil))

(defstruct box
  (data))

(defmacro make-pair (obj1 obj2)
  `(cons ,obj1 ,obj2))

(defmacro string-join (str1 str2)
  `(concatenate 'string ,str1 ,str2))

(defmacro with-next-token (input-stream &body forms)
  `(let* ((next (read-object ,input-stream))
          (next-symbol (token-symbol next))
          (next-literal (token-literal next)))
     ,@forms))

(defun parse (input-stream)
  "Initial state of the parser. It creates the AST along reading the first token"
  (with-next-token input-stream
    (let* ((ast (make-box :data (make-node :data nil :left nil :right nil)))
           (error-list '()))
      (when (null next)
        (enqueue (make-pair "Encountered End Of Line At Beginning Of Token Stream" 'error) error-list))

      (parse-reader next input-stream error-list ast))))

(defun parse-reader (token input-stream error-list ast)
  "parses valid reader directives"
  (with-next-token input-stream
    (let ((curr-symbol nil))

      (setf curr-symbol
            (cond ((string= (token-literal token) "--") 'line)
                  ((string= (token-literal token) "==") 'normal)
                  ((string= (token-literal token) "||") 'columns)
                  ((string= (token-literal token) "<=") 'backwards)
                  ((string= (token-literal token) "^^") 'bottom-up)
                  (t 'error)))

      (break (token-literal token))
      (cond ((eq curr-symbol 'error) (enqueue (make-pair (string-join "Found Unknown Reader-directive: " next-literal) 'error) error-list))
            ((null (token-symbol token)) (enqueue (make-pair "Found End Of line Reader Directive:" 'error) error-list)))

      (unless (eq-or curr-symbol 'error nil)
        (break "before insertion")
        (insert-node (box-data ast) token)
        (break "after insertion"))

        (case next-symbol
        (object-ref (parse-object-ref next input-stream error-list ast))
        (object-primitive (parse-object-ref next input-stream error-list ast))
        (regex (parse-regex next input-stream error-list ast))
        (reader-end (break "in case") (parse-reader-end next input-stream error-list ast))
        (otherwise (enqueue (make-pair (string-join "Expected Expression, Object Or Reader End But Found: " next-literal) 'error) error-list))))
    (make-pair ast error-list)))

(defun parse-escape (token input-stream error-list ast)
  (with-next-token input-stream
    (let ((possible-literal
            (cond ((string= next-literal "\BEEP")      (code-char 7))
                  ((string= next-literal "\BACKSPACE") (code-char 8))
                  ((string= next-literal "\TAB")       (code-char 9))
                  ((string= next-literal "\VTAB")      (code-char 11))
                  ((string= next-literal "\CRETURN")   (code-char 13))
                  ((string= next-literal "\NEWLINE")   (code-char 10))
                  ((string= next-literal "\FFEED")     (code-char 12))
                  (t 'error))))

      (cond ((null possible-literal) (enqueue (make-pair "Encountered End Of Line After Escape Sequence: " 'error) error-list))
            (t (enqueue (make-pair (string-join "Encountered Unrecognized Escape Sequence: " next-literal) 'error) error-list)))

      (case next-symbol
        (object-ref (parse-object-ref next input-stream error-list ast))
        (operator (parse-operator next input-stream error-list ast))
        (otherwise (enqueue (make-pair (string-join "Expected Object Reference But Found: " next-literal) ' error) error-list))))))

(defun parse-object-ref (token input-stream error-list ast)
  (with-next-token input-stream

    (insert-node (box-data ast) token)

    (cond ((string= next-literal "$") (parse-action token input-stream error-list ast))
          ((null (make-pair (string-join "Encountered End Of Line After Object Reference: " (token-literal token)) 'error))))

    (case next-symbol
      (object-ref (parse-object-ref next input-stream error-list ast))
      (range-delim (parse-range next input-stream error-list ast))
      (arg-delim (parse-arg next input-stream error-list ast))
      (otherwise (enqueue (make-pair (string-join "Unknown Or Invalid Token After Object Reference: " next-literal) 'error) error-list))))
  (make-pair ast error-list))

(defun parse-object-primitive (token input-stream error-list ast)
  (with-next-token input-stream
    (break (format nil "in parse object primitive (token literal :~a) ~% (next-literal ~a)" (token-literal token) next-literal))
    (insert-node (box-data ast) token)

     (when (null next)
       (enqueue (make-pair "Encountered End Of Line After Object Reference: " 'error) error-list))

     (case next-symbol
       (action-begin (parse-action next input-stream error-list ast))
       (range-delim (parse-range next input-stream error-list ast))
       (object-ref (parse-object-ref next input-stream error-list ast))
       (operator (parse-operator token input-stream error-list ast))
        (make-pair ast error-list))))

(defun parse-regex (token input-stream error-list ast)
  (with-next-token input-stream
    (insert-node (box-data ast) token)
    ;; Check and see if the token is a [
    (when (null next)
      (enqueue (make-pair "Encountered End Of Line After Regular Expression" 'error) error-list))

    (case next-symbol
      (operator (parse-operator next input-stream error-list ast))
      (action-begin (parse-action next input-stream error-list ast))
      (arg-delim (parse-arg next input-stream error-list ast))
      (otherwise (enqueue (make-pair (string-join "Unknown Or Invalid Token Found After Regular Expression:" next-literal) 'error) error-list))))
  (make-pair ast error-list))

(defun parse-arg (token input-stream error-list ast)
  (with-next-token input-stream

    (when (null next)
      (enqueue (make-pair (string-join "Encountered End Of Line After Parser Argument" next-literal) 'error) error-list))

    (case next-symbol
      (object-ref (parse-object-ref next input-stream error-list ast))
      (object-primitive (parse-object-primitive next input-stream error-list ast))
      (esc (parse-escape next input-stream error-list ast))
      (otherwise (enqueue (make-pair (string-join "Unknown Or Invalid Token Found After Regular Expression: " next-literal) 'error) error-list))))
  (make-pair ast error-list))

(defun parse-range (token input-stream error-list ast)
  (with-next-token input-stream

    (when (null next)
      (enqueue (make-pair "Encountered End Of Line After Parser Range" 'error) error-list))

    (case next-symbol
      (object-ref (parse-object-ref token input-stream error-list ast))
      (object-primitive (parse-object-primitive token input-stream error-list ast))
      (t (enqueue (make-pair (string-join "Unknown Or Invalid Token Found After Parser Range" next-literal) 'error) error-list))))
  (make-pair ast error-list))

(defun parse-action (token input-stream error-list ast)
  (with-next-token input-stream
    (when (null next)
      (enqueue (make-pair "Encountered End Of Line After Parser Range Or Assignment" 'error) error-list))

      (case next-symbol
        (object-primitive (parse-object-primitive next input-stream error-list ast))
        (object-ref (parse-object-ref next input-stream error-list ast))
        (otherwise (enqueue (make-pair (string-join "Unknown or Invalid Token Found After Parser Action: " next-literal) 'error) error-list))))
  (make-pair ast error-list))

(defun parse-unknown-token (token input-stream error-list ast)
  (with-next-token input-stream

    (enqueue (make-pair (string-join "Unknown Or Invalid Token Found After Parser Action: " (token-literal token)) 'error) error-list)
    (when (null token)
      (enqueue (make-pair "Encountered End Of Line After Unknown Token: " 'error) error-list))

    (case next-symbol
      (uknown-token (parse-unknown-token next input-stream error-list ast))
      (object-primitive (parse-object-primitive next input-stream error-list ast))
      (object-ref (parse-object-ref next input-stream error-list ast))

      (action-begin (parse-action next input-stream error-list ast))
      (action-end (parse-action-end next input-stream error-list ast))
      (operator (parse-operator next input-stream error-list ast))

      (range-delim (parse-range next input-stream error-list ast))
      (arg-delim (parse-arg next input-stream error-list ast))
      (regex (parse-regex next input-stream error-list ast))

      (esc (parse-escape next input-stream error-list ast))
      (reader (parse-reader token input-stream error-list ast))))
  (make-pair ast error-list))

(defun parse-operator (token input-stream error-list ast)
  (let ((stack '())
        (queue '()))

    ;; TODO add pemdas support
    ;; (when (null (parse-integer (token-literal tok) :junk-allowed t))
    ;;   (write-object (make-parser-error :token next :code 1 :severity 'warning))) ;; enacting operator

    ;; NOTE: does not parse PEMDAS, evals left top right
    (loop :for tok := (read-object input-stream)
          :if (or (eq (token-symbol tok) 'operator)
                  (eq (token-symbol tok) 'regex)) :do
                    (push tok stack)
          :else :if (eq (token-symbol tok) 'object) :do
            (enqueue tok queue)
          :else :do
            (when (null tok)
              (enqueue (make-pair "Encountered End Of Line After Operator" 'error) error-list))
            (enqueue (make-pair (string-join "Unknown Or Invalid Token Found In Expression: " next-literal) 'error) error-list)
            (loop-finish))

    (loop :for op :in stack :do
      (node-insert (box-data ast) op)
      (node-insert (box-data ast) (dequeue queue))
      (node-insert (box-data ast) (dequeue queue)))))

(defun parse-action-end (token input-stream error-list ast)
  (with-next-token input-stream
    ;; this may result as an error, currently debating on weather i want a EOL terminator or not, probably not tho
    ;; (when (null next)
    ;;   (report-error (make-parser-error :token token :code -8 :severity 'error)))
    (when (null next)
      (return-from parse-action-end (box-data ast)))

    (case next-symbol
      (action-begin (parse-action token input-stream error-list ast))
      (object-primitive (parse-action token input-stream error-list ast))
      (object-ref (parse-action token input-stream error-list ast))
      (otherwise (enqueue (make-pair (string-join "Unknown or Invalid Token Found After Action End Token: " next-literal) 'error) error-list)))
    (make-pair ast error-list)))

(defun parse-reader-end (token input-stream error-list ast)
  (with-next-token input-stream
    (break "in reader end")
    (case next-symbol
      (action-begin (parse-action next input-stream error-list ast))
      (object-primitive (parse-object-primitive next input-stream error-list ast))
      (object-ref (parse-object-ref next input-stream error-list ast))))
  (make-pair ast error-list))
