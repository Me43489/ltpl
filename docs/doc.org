#+Title: LTPL : Loki Text Processing Language Manual
#+Date: 2/7/22
#+STARTUP: latexpreview
* Introduction
** What Is This Exactly ?
   LTPL is a declaritive text processing and manipulation Domain Specific Langugage utility that specializes in making common
   text processing tasks as easily and tersely as possible.
** Who Is This For ?
   This is a tool mainly for programmers and users who require rigid formated text output. Specifically targeting
   those who would traditionally use awk to do so.
** Why Does This Exist ?
   I wanted a utility for text processing that was more flexible than Sed but more tearse than awk that
   that didnt contain the C-isms that was carried over as bagage from the Bell Labs Unix style thought process when designing awk.
** What This Tool Is
*** It is a Utility For Text Manipulation
    LTPL is more a utility along the lines of sed and awk than an actual language you would write in a file.
    It ment to be embedded in sh scripts and to be used either along side or be more versitle than more traditional tools.
** What This Tool Is Not    
*** It Is Not /Complete/ Replacement For Awk. 
    I am only comparing my language periodically to awk as the closest parallel of the language that exists and is in relitive popular use today.
    I am aware that awk is a more traditional language with a much more familar syntax that is ment to write programs and scripts that may be run from a file or piped in from another program.
    however the purpose of LTPL is explicitly for reading in and displaying data.
    
*** It Is Not A General Purpose Scripting Language
    This tool is not for all intensive purposes is not a scrihpting language nor should it ever be used as one.
    LTPL is a tearse and simple text processing utility and nothing more.
** Why The Cryptic Syntax
   LTPL's syntax and grammar is very simple aiming and being simple to use in a terminal enviroment.
   With this consideration taken a APL or Regular expression like syntax was considerd appropriate for a speedy interactive usage that I was trying to achieve.
* Essentals
  There are four core concepts exibit themselves in LTPL.
  The language its self is rather simple which makes it a very powerful tool for parsing text.

  - Objects
  - Reader Directives
  - Actions
  - Regular Expressions

** Objects
*** What Are Objects ?
    Objects in ltpl really are one of the most complex things in the entire language.
    but even though they are complex they are also rather simple in structure.
    Objects are heiarchical and able to be indexed quite simply as well.
    
*** Object Primitives    
    #+begin_src sh
    10 20 30 hello good bye 10.6    
    #+end_src
    all of these are strings 

    /All of which are examples of Object Primitives/
**** Indexing On Primitives
     in ltpl by default all objects are strings. and Like all strings you would be able to index into them. 
     given the object of: 
#+begin_src sh
    10
#+end_src
Lets say we want to get the second inner object of the of the object.
#+begin_src sh
    10$[1+1] -> 0
    10$[2] -> 0
    10$[0+2] -> 0
    10$[0+0+0+0+2] -> 0
    10$[.5*2]-> 0
    10$[0.5*2] -> 0
#+end_src
/each of these are equivlent due to arthicmatic evaluation/
the power of programmatic indexing is evident but at times we just want it to be simple. 
in practice you could 100% do this:
#+begin_src sh 
    10$[1] -> 1
#+end_src
because the first object that makes up the object primitive 10 is 1
However you could also write this which is entirely syntactically equivlent to the notation above:
#+begin_src sh
    10$1
#+end_src
Unfortenatly programatic indexing with this syntax is not possible. But it doesnt mean that this syntax isnt sound
#+begin_src sh 
    10$1+1 -> 2
#+end_src 
Instead of giving our desired result of 0 we get 2 due to the fact that ltpl
sees the object 10$1 as 1 evaluates it then adds 1 which results in 2.

#+begin_src sh
   30$1 is equvilent to 330$[1]
#+end_src


*** Object References
*** Fields And Implict Objects
**** Fields 
     Fields are the way that LTPL treats columns of text that are seperated by the $FS implicit object.
**** Implicit Objects
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | Name     | Description                                                                                                         | Type           |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $0       | The 0th field refering to the whole line of text. That contains an object array of                                  | Object Array   |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $n       | The $nth field that refers to an object that is broken up into fields by the $fs                                    | Integer Object |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $FS      | the delimiting character(s) that designantes the seperation of new tokens by a user defined or LTPL specified token | String Object  |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $CL      | the current line being read                                                                                         |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $PL      | previous line read                                                                                                  |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $NL      | the next line to be read.                                                                                           |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $NLR     | the number of lines that have been read.                                                                            |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $NTR     | the number of lines that need to be read.                                                                           |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $RED     | The Color Red                                                                                                       |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $GREEN   |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $BLUE    |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $BLACK   |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $WHITE   |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $CYAN    |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $MAGENTA |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $YELLOW  |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $PURPLE  |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $PINK    |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|
      | $ORANGE  |                                                                                                                     |                |   |
      |----------+---------------------------------------------------------------------------------------------------------------------+----------------+---|

      
      /where n is the number of fields/

*** User Defined Objects
    Objects In LTPL are able to be created by referancing a nonexistant object by using the $.
    typing the example nonsensecal case "$bar" is a proper object declaration.
*** Assignement
    Defining new variables along with reassigning existing ones are core parts of any programming language (except for the haskell purists out there)
    LTPL is no different but has a quirk to do so.
**** Examples     
     LTPL example.txt "==$bar[10]."\\
     LTPL example.txt "==$foo."\\
     /both of which are valid instances of objects where foo is assigned to an empty string by default and bar is assigned to 10/ \\
     
     $ ls \\

     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Desktop \\
     drwxr-xr-x 2 user user  4096 Feb  4 00:36 Documents \\
     drwxr-xr-x 3 user user  4096 Feb  6 23:16 Downloads \\
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Music \\ 
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Pictures \\
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Public \\ 
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Templates \\
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Videos \\

     ls -l | LTPL "==$3[~=$3]$foo[p].

     Output:

     drwxr-xr-x 2 user 4096 Jan 20 19:42 Desktop \\
     drwxr-xr-x 2 user 4096 Feb  4 00:36 Documents \\
     drwxr-xr-x 3 user 4096 Feb  6 23:16 Downloads \\
     drwxr-xr-x 2 user 4096 Jan 20 19:42 Music \\ 
     drwxr-xr-x 2 user 4096 Jan 20 19:42 Pictures \\
     drwxr-xr-x 2 user 4096 Jan 20 19:42 Public \\ 
     drwxr-xr-x 2 user 4096 Jan 20 19:42 Templates \\
     drwxr-xr-x 2 user 4096 Jan 20 19:42 Videos \\
     
*** Object Arrays And Subfields
    Subfields and object arrays are more or less equvilent. with the only real difference is in what is being refered. to put it simply:

    if it is a field it will be refered to as a subfield.
    if it is a user defined object it is refered to as an object array.
    /The encomapssing term between the two is object array/
**** Refering To  Object Arrays
     Below is a dummy file with that we will parse.\\
     \\
     Example.txt:\\
     hello world this is a tjest.

     if you notice there is a spelling error\\
     you can fix such a minute error like so\\
    
     LTPL Example.txt "--$6$2[~=$6$2]$6$1[>>]$0[p]."\\
     /where $6 is the 6th field while refering to the 2nd object field. deleting the object in said field and moving the object on the left next to it over where the previous object resided/
        
** Reader Directives
*** What Is A Reader Directive
    A Reader Directive is a command to the intepreter that directs the manner in which the input file will be parsed.

    There are two main Reader Directive types in LTPL.
    - Parsing Directives
    - Range Specifiers

**** *Parsing Directives*
      Parsing Directives which controls how the file is able to be read.
      there are a variety of different ways text can be formatted. 
      It is not always appropriate to read file left to right.
      
      /and yes im sorry ltpl is 1 indexed throught the language, but there is a very good reason/
      |-------------------+---------------------+--------------+--------------------------|
      | Reader Directives | Parse Description   | $FS Default  | Starting Cursor Position |
      |-------------------+---------------------+--------------+--------------------------|
      | ==                | parse left to right | " " Space    | (1,1)                    |
      |-------------------+---------------------+--------------+--------------------------|
      | \vert \vert       | column by column    | "\n" Newline | (1,1)                    |
      |-------------------+---------------------+--------------+--------------------------|
      | ^\vert            | column by column    | "\n" Newline | (1,n)                    |
      |-------------------+---------------------+--------------+--------------------------|
      | --                | Read a single line  | " " Space    | (1,n)                    |
      |-------------------+---------------------+--------------+--------------------------|
      | <=                | read right to left  | " " Space    | (n,1)                    |
      |-------------------+---------------------+--------------+--------------------------|
       /where n is the number of elements in that row or column/
       

Here is an example on how reader directives can be used with some formated input
      #+begin_src sh
      $ ls -l

      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Desktop 
      drwxr-xr-x 2 user user  4096 Feb  4 00:36 Documents
      drwxr-xr-x 3 user user  4096 Feb  6 23:16 Downloads
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Music 
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Pictures
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Public 
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Templates 
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Videos

      $ ls -l | ltpl "==$5[*:1024][p]."
      Output: 
           
      4194304 
      4194304 
      4194304 
      4194304 
      4194304 
      4194304
      4194304
      4194304 
      #+end_src 
      /where we are getting the 5th element and multiplying it by 1024 and printing the output/

Another way to achieve the same behavior but more efficently would be to do 
      #+begin_src sh
      $ ls -l

      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Desktop 
      drwxr-xr-x 2 user user  4096 Feb  4 00:36 Documents
      drwxr-xr-x 3 user user  4096 Feb  6 23:16 Downloads
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Music 
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Pictures
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Public 
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Templates 
      drwxr-xr-x 2 user user  4096 Jan 20 19:42 Videos

      $ ls -l | ltpl "||$5[*:1024][p]."

      4194304 
      4194304 
      4194304 
      4194304 
      4194304 
      4194304
      4194304
      4194304 
      #+end_src 
      The only difference here from the example above is the way that the interpter reads the information.
      instead of reading every single field starting with /drwxr-xr-2/ and ending when we find $5 which in this case is 4096.
      we can get entire columns of text just by reading by column.

Examples of the other reader directives being used can be found at .... (havent made a place for it yet)

**** *Range Specifiers*
     
     There are a lot of times we want to ommit certain places where we have junk in a file. 
     By junk I dont really mean garbage in the sense that its not important but I mean
     that its not applicable for what we need.
     
     you can achieve this by using Range Specifiers which controls what field the given lines of the input will be read.

     A Position Specifier may be used in combitation with a Parser Directive to give more flexibilty to the user;
     detailing what subset of data of the input that will be read.

     given the following syntax.\\
     #+begin_src sh
     "||0,1"
     #+end_src
     /which reads each column skipping the first column entirely/
     
A practical application to get all of the numbers on line 5 would be
     #+begin_src sh
     $ cat file.txt
     John Doe
     March 21st, 2022
     John_The_Doe@hotmail.com (because I feel hotmail is funny)
     
     10 20 30 40 50
     hello good bye
     
     $ ltpl file.txt "--5,5[p]"
     10 20 30 40 50
     #+end_src
     /where it reads only one singular line of text at line 5 and prints it/
** Actions
*** What Is An Action
    An action is the primary enact changes to Objects. they are syntactically represented within [].
**** Example     
     $ ls -l \\
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Desktop \\
     drwxr-xr-x 2 user user  4096 Feb  4 00:36 Documents \\
     drwxr-xr-x 3 user user  4096 Feb  6 23:16 Downloads \\
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Music \\
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Pictures \\ 
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Public \\
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Templates \\
     drwxr-xr-x 2 user user  4096 Jan 20 19:42 Videos \\
     
     ls -l | LTPL "==$6[p]" \\
     
     Output: \\
     Jan \\
     Feb \\
     Feb \\ 
     Jan \\
     Jan \\
     Jan \\
     Jan \\
     Jan \\
     
*** Actions Predefined
**** Output And More Output
     Keeping within the bound of the promise that this is not a scripting language There is no way to prompt users for input what so ever.
     In LTPL There a variety of different mechinisms that the user to write to a file of their choice.
***** Writing To Files
      What Would a text processing language be with out being able to save the manipulated text to files write to files.
*** Why Can't I Define My Own Actions
    well there is a simple answer to that. LTPL is not a scripting language. If you feel you need to define your own actions to make a certain action easier. you should look at some other language.
    consider using AWK or perl. heck sed can be useful in some circumstances. 
*** Possible Actions

    
    |-----------------+---------------+---------------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------+---------------------+---|
    | Name            | Symbolic Name | Description                                                                           | Possible Arguments             | Examples                                        | program description |   |
    |-----------------+---------------+---------------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------+---------------------+---|
    | print           | p             | Prints an object to stdout                                                            | p -red -green -blue \vert none | ---$1[p 255,0,0].                               |                     |   |
    | write           | w             | writes objects to a file                                                              | w -filename \vert -filename    | ---$0[w file.txt].                              |                     |   |
    |-----------------+---------------+---------------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------+---------------------+---|
    | filter          | ~             | removes if condition is true                                                          | ~ -logical operator -object    | ---$0[~=10][p].                                 |                     |   |
    | cast to type    | ->            | given an object it converts it to the type of a given object                          | -> -object                     | ---$1[-> 10][p]                                 |                     |   |
    | ternary         | ?             | does the next action if true the other if false                                       | ? - logical operator object    | ---$1[? = 10]Success[p 0 255,0]fail[p 255,0,0]. |                     |   |
    |-----------------+---------------+---------------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------+---------------------+---|
    | italic          | i             |                                                                                       | none                           | ---$0[i][p].                                    |                     |   |
    | bold            | b             |                                                                                       | none                           |                                                 |                     |   |
    | underline       | _             | underlines an object                                                                  | none                           | ---$0[_][p].                                    |                     |   |
    | highlight       | #             | highlights an object                                                                  | none                           | ---$0[                                          |                     |   |
    | shift down line | VV            | shfits an object down into the line below it.                                         |                                |                                                 |                     |   |
    | shift up line   | ^^            |                                                                                       |                                |                                                 |                     |   |
    | Swap lines
    | Move Right      | >>            | shifts an object right by one field replacing the object that inhabited that location | none                           | ---$1[>>]$2[p].                                 |                     |   |
    | Move Left       | <<            | shifts an object left by one field replacing the object that inhabited that location  | none                           |                                                 |                     |   |
    |-----------------+---------------+---------------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------+---------------------+---|
    
* Implentation Details
* Examples
* Benchmarks
ure Ideas
* Grammar BNF


